package auth

import (
	"errors"

	"github.com/google/uuid"
	"github.com/modernice/goes/aggregate"
	"github.com/modernice/goes/event"
)

// ActorAggregate is the name of the Actor aggregate.
const ActorAggregate = "goes.contrib.auth.actor"

// Built-in Actor kinds
const (
	UUIDActor   = "uuid"
	StringActor = "string"
)

var (
	// ErrIDType is returned when trying to identify an actor with an id that
	// has a type other that the configured type.
	ErrIDType = errors.New("invalid id type")

	// ErrMissingActorID is returned when trying to grant or revoke permissions
	// to or from a non-UUID-Actor before the actor has been identified.
	ErrMissingActorID = errors.New("missing actor id")
)

// An Actor represents any kind of user in the system. Actors are granted
// permissions to perform actions on specific aggregates within an application.
//
// Note that an Actor itself does not provide the full set of permissions that
// the actor may have. This can be the case if the actor is a member of a role
// (roles grant permissions to a group of actors). To get the full set of
// permissions of a specific actor, project the Permissions read-model for that
// specific actor.
//
// Actors for users that are identified by a UUID can be created using NewUUIDActor.
//	var userID uuid.UUID
//	ref := aggregate.Ref{Name: "<aggregate-name>", ID: "<aggregate-id>"}
//	actor := auth.NewUUIDActor(userID)
//	actor.Grant(ref, "action-1", "action-2", "...")
//	actor.Revoke(ref, "action-1", "action-2", "...")
//
// Actors for users that are identified by a string can be created using
// NewStringActor. Note that the string is not used as the aggregate id (UUID)
// of the actor. Instead, the string must be passed to the Identify() method of
// the actor before the actor can be granted or revoked permissions.
//	ref := aggregate.Ref{Name: "<aggregate-name>", ID: "<aggregate-id>"}
//	actor := auth.NewStringActor(uuid.New())
//	actor.Identify("<some-string-id>")
//	actor.Grant(ref, "action-1", "action-2", "...")
//	actor.Revoke(ref, "action-1", "action-2", "...")
type Actor struct {
	*aggregate.Base

	kind        string
	id          any
	isUUIDActor bool
	validateID  func(any) error
	parseID     func(string) (any, error)
	formatID    func(any) string
	Actions
}

// NewUUIDActor returns the actor that is identified by the provided UUID.
// A UUID-Actor may refer to any kind of user that is identified by a UUID.
// Most commonly, this would simply be a user aggregate but it can actually be
// anything that provides a UUID.
func NewUUIDActor(id uuid.UUID) *Actor {
	a := NewActor(id, ActorConfig[uuid.UUID]{
		Kind:     UUIDActor,
		ParseID:  uuid.Parse,
		FormatID: func(id uuid.UUID) string { return id.String() },
	})
	a.id = id
	a.isUUIDActor = true
	return a
}

// NewStringActor returns an actor that is identified by a string.
// A string-Actor may refer to any kind of user that is identified by a simple
// string. Most commonly, this would be some kind of API key or token.
//
// Example
//
// Imagine an ecommerce app that doesn't force customers to create an account to
// order products. Customers receive an email with a link that allows them to
// view and update their order. The links that are sent to the customers include
// a token that the API uses to authorize the customer's requests.
//
//	var orderID uuid.UUID
//	var token string // generated by the application
//	actor := auth.NewStringActor(uuid.New())
//	actor.Identify(token)
//	actor.Grant("order", orderID, "view", "cancel", ...)
func NewStringActor(id uuid.UUID) *Actor {
	return NewActor(id, ActorConfig[string]{
		Kind:     StringActor,
		ParseID:  func(s string) (string, error) { return s, nil },
		FormatID: func(s string) string { return s },
	})
}

// ActorConfig is used by NewActor to configure the actor.
type ActorConfig[ID comparable] struct {
	// Kind is the type of the actor's id. A string-Actor has the "string" kind,
	// a UUID-Actor has the "uuid" kind. The kind is used to get the correct
	// Actor repository from ActorRepositories.
	Kind string

	// ParseID parses the formatted actor id that is returned by FormatID back
	// to the actual ID.
	ParseID func(string) (ID, error)

	// FormatID formats the actor id to a string. The formatted string is used
	// as the event data of the ActorIdentified event.
	FormatID func(ID) string
}

// NewActor creates a generic actor that uses the provided ActorConfig to format
// and parse the actor's id (not the aggregate id). NewActor can be used to
// implement additional actor types besides UUID-Actors and string-Actors.
// If cfg.ParseID or cfg.FormatID is not provided, NewActor panics.
func NewActor[ID comparable](id uuid.UUID, cfg ActorConfig[ID]) *Actor {
	if cfg.Kind == "" {
		panic("[goes/contrib/auth.NewActor] missing Kind option")
	}

	if cfg.ParseID == nil {
		panic("[goes/contrib/auth.NewActor] missing ParseID option")
	}

	if cfg.FormatID == nil {
		panic("[goes/contrib/auth.NewActor] missing FormatID option")
	}

	parseID := func(v string) (any, error) { return cfg.ParseID(v) }
	formatID := func(v any) string { return cfg.FormatID(v.(ID)) }

	a := &Actor{
		Base: aggregate.New(ActorAggregate, id),
		kind: cfg.Kind,
		validateID: func(v any) error {
			if _, ok := v.(ID); !ok {
				return ErrIDType
			}
			return nil
		},
		parseID:  parseID,
		formatID: formatID,
		Actions:  make(Actions),
	}

	event.ApplyWith(a, a.identify, ActorIdentified)
	event.ApplyWith(a, a.Actions.granted, PermissionGranted)
	event.ApplyWith(a, a.Actions.revoked, PermissionRevoked)

	return a
}

// ActorID returns the id of the actor (not the aggregate id).
func (a *Actor) ActorID() any {
	return a.id
}

// ActorKind returns the kind of the actor. Built-in kinds are "uuid" and "string".
func (a *Actor) ActorKind() string {
	return a.kind
}

// Identify sets the provided id as the actor id of the actor. This must be done
// for any actor that is not a UUID-Actor before the actor can be granted
// permissions. If the actor is a UUID-Actor, Identify() is a no-op.
func (a *Actor) Identify(id any) error {
	if a.isUUIDActor {
		return nil
	}

	if err := a.validateID(id); err != nil {
		return err
	}

	aggregate.Next(a, ActorIdentified, ActorIdentifiedData(a.formatID(id)))

	return nil
}

func (a *Actor) identify(evt event.Of[ActorIdentifiedData]) {
	if a.isUUIDActor {
		return
	}

	sid := string(evt.Data())
	if err := a.validateID(sid); err != nil {
		return
	}

	id, err := a.parseID(sid)
	if err != nil {
		return
	}

	a.id = id
}

// Allows returns whether the actor is allowed to perform the given action.
// Allows does not account for the roles the actor is a member of (use the
// Permissions read-model instead).
func (a *Actor) Allows(action string, ref aggregate.Ref) bool {
	return a.allows(action, ref)
}

// Disallows returns whether the actor is allowed to perform the given action.
// Disallows does not account for the roles the actor is a member of (use the
// Permissions read-model instead).
func (a *Actor) Disallows(action string, ref aggregate.Ref) bool {
	return !a.allows(action, ref)
}

// Grant grants the actor the permission to perform the given actions on the
// given aggregate. Grant does not affect the permissions that were granted to
// the actor through a role.
//
// Wildcards
//
// Grant supports wildcards in the aggregate reference and actions.
// Pass in a "*" where a string is expected or uuid.Nil where a UUID is expected
// to match all values.
//
// Example – Grant "view" permission on all aggregates with a specific id:
//	var id uuid.UUID
//	actor.Grant(aggregate.Ref{Name: "*", ID: id}, "view")
//
// Example – Grant "view" permission on "foo" aggregates with any id:
//	actor.Grant(aggregate.Ref{Name: "foo", ID: uuid.Nil}, "view")
//
// Example – Grant "view" permission on all aggregates:
//	actor.Grant(aggregate.Ref{Name: "*", ID: uuid.Nil}, "view")
//
// Example – Grant all permissions on all aggregates:
//	actor.Grant(aggregate.Ref{Name: "*", ID: uuid.Nil}, "*")
func (a *Actor) Grant(ref aggregate.Ref, actions ...string) error {
	if len(actions) == 0 {
		return nil
	}

	if err := a.checkID(); err != nil {
		return err
	}

	if err := validateRef(ref); err != nil {
		return err
	}

	aggregate.Next(a, PermissionGranted, PermissionGrantedData{
		Aggregate: ref,
		Actions:   actions,
	})

	return nil
}

func (a *Actor) checkID() error {
	if a.id == nil {
		return ErrMissingActorID
	}
	return nil
}

// Revoke revokes the permission to perform the given actions on the given
// aggregate from the actor. Revoke does not affect the permissions that were
// granted to the actor through a role.
//
// Wildcards
//
// Revoke supports wildcards in the aggregate reference and actions.
// Pass in a "*" where a string is expected or uuid.Nil where a UUID is expected
// to match all values.
//
// Example – Revoke "view" permission on all aggregates with a specific id:
//	var id uuid.UUID
//	actor.Revoke(aggregate.Ref{Name: "*", ID: id}, "view")
//
// Example – Revoke "view" permission on "foo" aggregates with any id:
//	actor.Revoke(aggregate.Ref{Name: "foo", ID: uuid.Nil}, "view")
//
// Example – Revoke "view" permission on all aggregates:
//	actor.Revoke(aggregate.Ref{Name: "*", ID: uuid.Nil}, "view")
//
// Example – Revoke all permissions on all aggregates:
//	actor.Revoke(aggregate.Ref{Name: "*", ID: uuid.Nil}, "*")
func (a *Actor) Revoke(ref aggregate.Ref, actions ...string) error {
	if len(actions) == 0 {
		return nil
	}

	if err := a.checkID(); err != nil {
		return err
	}

	if err := validateRef(ref); err != nil {
		return err
	}

	aggregate.Next(a, PermissionRevoked, PermissionRevokedData{
		Aggregate: ref,
		Actions:   actions,
	})

	return nil
}
